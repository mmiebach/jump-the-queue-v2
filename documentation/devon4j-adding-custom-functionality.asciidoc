:toc: macro
toc::[]
:idprefix:
:idseparator: -
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= devon4j adding Custom Functionality
In the xref:devon4j-layers[previous chapter] we have seen that, using _CobiGen_, we can generate all the structure and functionality of a _devon4j_ component in a few clicks.

In this chapter we are going to show how to add custom functionalities to our projects, that are out of the scope of code, that _CobiGen_ is able to generate.

== Return the Access Code
The _JumpTheQueue_ design defines a xref:jump-the-queue-design#user-story-register[User Story] in which an owner can register into an event and obtain an access code to avoid a queue.

In our _standard_ implementation of the _JumpTheQueue_ app we have used _CobiGen_ to generate the components, so we have a default implementation of the services. Since the _AccessCode_ component is more complex and requires the use of _CTOs_, we need to create our own _usecasemanage_ and the methods _save_ and _delete_.
We also have to add some methods to the Queue component.

=== Adding Methods Process

The process of adding a method to any component requires the floowing steps:

. Modify the corresponding `usecase` interface, adding the methods.
. Implement the methods in the `usecaseimpl`.
. Modify the management implementation `managementimpl`.

=== Adding Methods to the Queue Component

First we want to add a method that initializes a given queue: We will call it `startQueue`.

==== 1. Modifying UcManageQueue

Inside `jtqj-api` in the `queuemanagement/logic/api/usecase/UcManageQueue` the declaration of the method will be added:

[source,java]
----
package com.devonfw.application.jtqj.queuemanagement.logic.api.usecase;
...

/**
   * Starts a queue
   *
   * @param queue the {@link QueueEto} to start.
   * @return the new {@link QueueEto} that has been started.
   */
  QueueEto startQueue(QueueEto queue);

----

==== 2. Implementing the Method in UcManageQueueImpl

In `jtqj-core/src/main/java/queuemanagement/logic/impl/usecase/UcManageQueueImpl` the implementation of the method, that was just added in the interface, is going to be added:

[source,java]
----
...
 @Inject
  Accesscodemanagement accessCodeManagement;

  @Override
  public QueueEto startQueue(QueueEto queue) {
      QueueEntity queueEntity = getBeanMapper().map(queue, QueueEntity.class);

      if (queueEntity.getStarted()) {
          LOG.debug("Queue with id '{}' is already started.", queueEntity.getId());
      } else {
          queueEntity.setStarted(true);
          QueueEntity resultEntity = getQueueRepository().save(queueEntity);

          // Update all codes related to such queue
          accessCodeManagement.updateCodesOnStartQueue(resultEntity.getId());
          LOG.debug("Queue with id '{}' has been started.", resultEntity.getId());
          queue = getBeanMapper().map(resultEntity, QueueEto.class);

          // SSE
          List<SseEmitter> sseEmitterListToRemove = new ArrayList<>();
          ServerSse.emitters.forEach((SseEmitter emitter) -> {
              try {
                  emitter.send(SseEmitter.event().data(getBeanMapper().map(resultEntity, QueueEto.class), MediaType.APPLICATION_JSON).name("QUEUE_STARTED"));
              } catch (IOException e) {
                  emitter.complete();
                  sseEmitterListToRemove.add(emitter);
                  LOG.error(e.toString());
              }
          });
          ServerSse.emitters.removeAll(sseEmitterListToRemove);

      }
      return queue;
  }

----

There will now be some errors related to ServerSse, List, MediaType and accesscodemanagement. The first two errors will be resolved now, the error related to accesscodemanagement will be resolved when we work on the AccessCode component.


===== Resolving the ServerSse error

In `jtqj-core/com.devonfw.application.jtqj.accesscodemanagement.service.impl.rest` add a new java class called `ServerSse` containing the following:

[source,java]
----
package com.devonfw.application.jtqj.accesscodemanagement.service.impl.rest;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@RestController
public class ServerSse {

    public static final List<SseEmitter> emitters = Collections.synchronizedList(new ArrayList<>());

    @RequestMapping(path = "/stream/subscribe", method = RequestMethod.GET)
    public SseEmitter stream() throws IOException {
        SseEmitter emitter = new SseEmitter();
        emitters.add(emitter);
        emitter.onCompletion(() -> emitters.remove(emitter));
        return emitter;
    }
}
----
Now we have to import the `ServerSse`-class into `UcManageQueueImpl`. 
In `jtqj-core/src/main/java/com/devonfw/application/jtqj/queuemanagement/logic/impl/usecase` add 
`import com.devonfw.application.jtqj.accesscodemanagement.service.impl.rest.ServerSse;` to `UcManageQueueImpl`

===== Resolving the errors related to List and MediaType

We also need to import List: `import java.util.List;` and `Media Type` with `import org.springframework.http.MediaType;` in `UcManageQueueImpl`.


==== 3.Modifying QueuemanagementImpl


There will appear an error in `QueuemanagementImpl`, as `startQueue` is still missing here.
We therefore have to add `startQueue` to `QueuemanagementImpl`.
In `queuemanagement/logic/impl/Queuemanagement` add the missing method:

[source,java]
----
@Override
	public QueueEto startQueue(QueueEto queue) {
		return this.ucManageQueue.startQueue(queue);
	}
----

There will be one error remaining in the UcManageQueueImpl regarding accesscodemanagement. This error will be resolved, when working on the AccessCode component.


=== Modifying UcFindQueue
 
In `jtqj-api/src/main/java/com.deovonfw.application.jtqj/queuemanagement/logic/api/usecase/UcFindQueue.java` add the following Method:

[source,java]
----
...
/**
   * Returns the daily queue
   *
   * @return The {@link QueueEto} that match current day/month/year
   */
  QueueEto findDailyQueue();
----

We will have to implement this method `findDailyQueue` in `UcFindQueueImpl`:

[source,java]
----
@Inject
	Queuemanagement queuemanagement;
	@Override
	public QueueEto findDailyQueue() {
		// Return today's queue (create if not exists)
		Boolean todayQueue = false;
		QueueSearchCriteriaTo criteria = new QueueSearchCriteriaTo();
		criteria.setPageable(PageRequest.of(0, 1, Sort.by(Sort.Direction.DESC,"createdDate")));
		Page<QueueEntity> queues = getQueueRepository().findByCriteria(criteria);
		QueueEto respQueue = new QueueEto();

		if (!queues.getContent().isEmpty()) {
			// Check if we have today's queue
			QueueEto lastQueue =  getBeanMapper().map(queues.getContent().get(0), QueueEto.class);
			todayQueue = queueToday(lastQueue.getCreatedDate());
			respQueue = lastQueue;
		}
		if(!todayQueue) {
			// Create a queue for today
			QueueEto newQueue = new QueueEto();
			QueueEto savedQueue = queuemanagement.saveQueue(newQueue);
			respQueue = savedQueue;
		}
		return respQueue;
	}

	private Boolean queueToday(Timestamp queueTimestamp) {
		Boolean haveQueue = false;
		LocalDate queueTimeParsed = queueTimestamp.toLocalDateTime().toLocalDate();
		LocalDate today = LocalDate.now();
		haveQueue = queueTimeParsed.getYear() == today.getYear() && queueTimeParsed.getDayOfYear() == today.getDayOfYear();
		return haveQueue;
	}
----

We have to add `findDailyQueue` in `jtqj-core/src/main/java/com.devonfw.application.jtqj/queuemanagement/logic/impl/usecase/Queuemanagement.java`


[source,java]
----
...
@Override
  public QueueEto findDailyQueue() {

    return this.ucFindQueue.findDailyQueue();
  }
----


To resolve the errors, import Timestamp (`import java.sql.Timestamp;`) and sort (`import org.springframework.data.domain.Sort;`)



=== Creating the usecasemanage for the AccessCode

==== Adding method to the AccessCode _usecasefind_
Before creating the usecasemanage, a method needs to be added to the usecasefind, that will recover our `AccessCodeEto`. In `jtqj-api`, inside the package `accesscodemanagement/logic/api/usecase/`, the file `UcFindAccessCode` is going to be modified, adding the new method to the interface:

[source,java]
----
...

import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.AccessCodeEto;

...

public interface UcFindAccessCode {

  ...

  /**
   * Returns a paginated list of AccessCodeEto matching the search criteria.
   *
   * @param criteria the {@link AccessCodeSearchCriteriaTo}.
   * @return the {@link List} of matching {@link AccessCodeEto}s.
   */
  Page<AccessCodeEto> findAccessCodes(AccessCodeSearchCriteriaTo criteria);

}
----

Once that is finished, we will see that an error is going to appear in `UcFindAccessCodeImpl` and `AccesscodemanagementImpl`. In `accesscodemanagement/logic/impl/usecase/UcFindAccessCodeImpl` we need to implement the method:

[source,java]
----
...

public class UcFindAccessCodeImpl extends AbstractAccessCodeUc implements UcFindAccessCode {

  ...

  @Override
  public Page<AccessCodeEto> findAccessCodes(AccessCodeSearchCriteriaTo criteria) {

    Page<AccessCodeEntity> accessCodes = getAccessCodeRepository().findByCriteria(criteria);

    return mapPaginatedEntityList(accessCodes, AccessCodeEto.class);
  }

}
----

This method uses an `AcessCodeSearchCriteriaTo` to find a page of entities -- `AccessCodeEntity` -- using the repository. After that, it changes the mapping of the list from `AccessCodeEntity` to `AccessCodeEto`. 

Now we will add the method to AccessCodemanagementImpl:

[source,java]
----
@Override
	public Page<AccessCodeEto> findAccessCodes(AccessCodeSearchCriteriaTo criteria) {
		return this.ucFindAccessCode.findAccessCodes(criteria);
	}

----

We will now define some methods for later use:

in `UcFindAccessCode` add:

[source, java]
----

...


	/**
	 * Returns a list of Etos associated with a queue.
	 *
	 * @param queueId.
	 * @return the {@link List} of matching {@link AccessCodeEto}s.
	 */
	List<AccessCodeEto> findByQueue(long queueId);

	/**
	 * Returns a current AccessCode of dailyQueue.
	 *
	 * @return The {@link AccessCodeEto} with status Attending
	 */
	AccessCodeEto findCurrentCode();

	/**
	 * Returns a next AccessCode of dailyQueue.
	 *
	 * @param id The id 'id' of the dailyQueue.
	 * @return The {@link AccessCodeEto} with status waiting and farthest in createdTime
	 */
	NextCodeCto findNextCode(long queueId);

	/**
	 * Returns a next AccessCode of dailyQueue.
	 *
	 * @param id The id 'id' of the dailyQueue.
	 * @return The {@link AccessCodeEto} with status waiting and farthest in createdTime
	 */
	RemainingCodes findRemainingCodes();

	/**
	 * Returns a AccessCode by its id 'id'.
	 *
	 * @param id The id 'id' of the AccessCode.
	 * @return The {@link AccessCodeEto} with id 'id'
	 */
	AccessCodeEto findAccessCode(long id);
----

We will now get some errors related to the last two methods. We will therefore create classes for these:

A class `NextCodeCto` will be added in `jtqj-api/src/main/java/com.devonfw.application.jtqj.accesscodemanagement.logic.api.to` with

[source, java]
----
public class NextCodeCto {
  private AccessCodeEto accessCode;

  /**
   * @return the accessCode
   */
  public AccessCodeEto getAccessCode() {

    return this.accessCode;
  }

  /**
   * @param accessCode the accessCode to set
   */
  public void setAccessCode(AccessCodeEto accessCode) {

    this.accessCode = accessCode;
  }

  /**
   * @return the remainingCodes
   */
  public RemainingCodes getRemainingCodes() {

    return this.remainingCodes;
  }

  /**
   * @param remainingCodes the remainingCodes to set
   */
  public void setRemainingCodes(RemainingCodes remainingCodes) {

    this.remainingCodes = remainingCodes;
  }

  private RemainingCodes remainingCodes;
}
----

For this class we need a class `RemainingCodes` also in jtqj-api/src/main/java/com.devonfw.application.jtqj.accesscodemanagement.logic.api.to` with:

[source,java]
----
public class RemainingCodes {
	private int remainingCodes;

	/**
	 * @return the remainingCodes
	 */
	public int getRemainingCodes() {
		return remainingCodes;
	}

	/**
	 * @param remainingCodes the remainingCodes to set
	 */
	public void setRemainingCodes(int remainingCodes) {
		this.remainingCodes = remainingCodes;
	}
}

----

We will also need to import these:

[source, java]
----
...

import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.NextCodeCto;
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.RemainingCodes;

...

----

Now we will implement these methods in UcFindAccessCodeImpl:

[source, java]
----
@Override
	public RemainingCodes findRemainingCodes() {
		RemainingCodes remaining = new RemainingCodes();
		QueueEto dailyQueue = queueManagement.findDailyQueue();
		AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
		criteria.setQueueId(dailyQueue.getId());
		criteria.setStatus(Status.WAITING);
		Page<AccessCodeEntity> accessCodes = getAccessCodeRepository().findByCriteria(criteria);
		remaining.setRemainingCodes(accessCodes.getContent().size());
		return remaining;
	}


@Override
public AccessCodeEto findCurrentCode() {
	QueueEto dailyQueue = queueManagement.findDailyQueue();
	AccessCodeEto currentCode = new AccessCodeEto();
	AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
	criteria.setQueueId(dailyQueue.getId());
	criteria.setStatus(Status.ATTENDING);
	Page<AccessCodeEntity> accessCode = getAccessCodeRepository().findByCriteria(criteria);
	// Check if we have a current code
	if (accessCode.getContent().size() == 1) {
	currentCode = getBeanMapper().map(accessCode.getContent().get(0), AccessCodeEto.class);
	}
	return currentCode;
}

@Override
  public NextCodeCto findNextCode(long queueId) {

    NextCodeCto nextCodeCto = new NextCodeCto();
    RemainingCodes remainingCodes = new RemainingCodes();
    AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
    criteria.setQueueId(queueId);
    criteria.setStatus(Status.WAITING);
    criteria.setPageable(PageRequest.of(0, Integer.MAX_VALUE, Sort.by(Sort.Direction.ASC, "createdDate")));
    Page<AccessCodeEntity> accessCode = getAccessCodeRepository().findByCriteria(criteria);
    remainingCodes.setRemainingCodes(accessCode.getContent().size());
    nextCodeCto.setRemainingCodes(remainingCodes);
    if (!accessCode.getContent().isEmpty()) {
      nextCodeCto.setAccessCode(getBeanMapper().map(accessCode.getContent().get(0), AccessCodeEto.class));
    }
    return nextCodeCto;
  }

@Override
public List<AccessCodeEto> findByQueue(long queueId) {
	List<AccessCodeEto> etos = new ArrayList<>();
	AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
	criteria.setQueueId(queueId);
	Page<AccessCodeEntity> accessCodes = getAccessCodeRepository().findByCriteria(criteria);
	for (AccessCodeEntity entity : accessCodes.getContent()) {
		etos.add(getBeanMapper().map(entity, AccessCodeEto.class));
	}
	return etos;
}

@Override
public AccessCodeEto findAccessCode(long id) {
	LOG.debug("Get AccessCode with id {} from database.", id);
	Optional<AccessCodeEntity> foundEntity = getAccessCodeRepository().findById(id);
	if (foundEntity.isPresent())
		return getBeanMapper().map(foundEntity.get(), AccessCodeEto.class);
	else
		return null;
}
----

We will need to import some classes:

import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.RemainingCodes;

import com.devonfw.application.jtqj.general.common.api.Status;

import java.util.Optional;

Now add the methods to the AccesscodeManagementImpl:


[source, java]
----
...
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.RemainingCodes;
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.NextCodeCto;
... 
  @Override
  public Page<AccessCodeEto> findAccessCodes(AccessCodeSearchCriteriaTo criteria) {

    return this.ucFindAccessCode.findAccessCodes(criteria);
  }

  @Override
  public List<AccessCodeEto> findByQueue(long queueId) {

    return this.ucFindAccessCode.findByQueue(queueId);
  }

  @Override
  public AccessCodeEto findCurrentCode() {

    return this.ucFindAccessCode.findCurrentCode();
  }

  @Override
  public NextCodeCto findNextCode(long queueId) {

    return this.ucFindAccessCode.findNextCode(queueId);
  }

  @Override
  public RemainingCodes findRemainingCodes() {

    return this.ucFindAccessCode.findRemainingCodes();
  }
 
  @Overrride
  public AccessCodeEto findAccessCode(long id) {

    return this.ucFindAccessCode.findAccessCode(id);
  }

----


==== Creating the _usecasemanage_
In `jtqj-api`, inside the package `accesscodemanagement/logic/api/usecase/`, we are going to create a new interface called `UcManageAccessCode`, where we will define the save and delete methods.
Also we will define the methods `updateCodesOnStartQueue`, `NextCodeCto` and `EstimatedTime`.
[source,java]
----
...

import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.AccessCodeEto;

public interface UcManageAccessCode {

  /**
   * Deletes an accessCode from the database by its ID 'accessCodeId'. Decreases the count of customers of the queue
   * assigned to the access code by one.
   *
   * @param queueId Id of the queue to delete
   */
  boolean deleteAccessCode(long accessCodeId);

  /**
   * Saves a queue and stores it in the database. Increases the count of customers of the queue assigned to the access
   * code by one.
   *
   * @param queue the {@link AccessCodeEto} to create.
   * @return the new {@link AccessCodeEto} that has been saved with ID and version.
   */
  AccessCodeEto saveAccessCode(AccessCodeEto accessCodeEto);

  /**
   * Updates all accesCodes when a queue starts
   *
   * @param List of accessCodes related to such queue the {@link AccessCodeEto} to update.
   * @return void
   */
  void updateCodesOnStartQueue(long queueId);

  /**
   * Updates the current code and next code if available
   *
   * @return {@link AccessCodeCto} if available, else code will be empty
   */
  NextCodeCto callNextCode();


  /**
   * @param accessCode
   * @return the estimatedTime for given access code
   */
  EstimatedTime calculateEstimatedTime(AccessCodeEto accessCode);

}
----


`EstimatedTime` does not exist yet.
We will therefore add a Class in `jtqj-api/src/main/java/com.devonfw.application.jtqj.accesscodemanagement.logic.api.to` called `EstimatedTime` with the following code:

[source,java]
----
public class EstimatedTime {
  private long miliseconds;

  private long defaultTimeByUserInMs;

  /**
   * @return the defaultTimeByUserInMs
   */
  public long getDefaultTimeByUserInMs() {

    return this.defaultTimeByUserInMs;
  }

  /**
   * @param defaultTimeByUserInMs the defaultTimeByUserInMs to set
   */
  public void setDefaultTimeByUserInMs(long defaultTimeByUserInMs) {

    this.defaultTimeByUserInMs = defaultTimeByUserInMs;
  }

  /**
   * @return the estimated
   */
  public long getMiliseconds() {

    return this.miliseconds;
  }

  /**
   * @param estimated the estimated to set
   */
  public void setMiliseconds(long miliseconds) {

    this.miliseconds = miliseconds;
  }
}
----


We will need to import these classes to resove the resulting errors:

[source, java]
----
...
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.EstimatedTime;
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.NextCodeCto;
...
----


Similar to the Quemanagement, we want the AccessCodemanagement to implement UcManageCode: In `jtqj-api/src/main/java/com/devonfw/application/jtqj/accesscodemanagement/logic/api/Accesscodemanagement` add UcManageCode. It should look like this:
[source,java]
----
package com.devonfw.application.jtqj.accesscodemanagement.logic.api;

import com.devonfw.application.jtqj.accesscodemanagement.logic.api.usecase.UcFindAccessCode;
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.usecase.UcManageAccessCode;
/**
 * Interface for Accesscodemanagement component.
 */
public interface Accesscodemanagement extends UcFindAccessCode, UcManageAccessCode {

}
----

Then in `jtqj-core`, inside the package `accesscodemanagement/logic/impl/usecase`, we are going to create a class called `UcManageAccessCodeImpl`, implementing `UcManageAccessCode` and extending `AbstractAccessCodeUc`. This will allow us to have access to the repository.

Also, here is the part where we will use the methods that we created in the `Queue` component:

[source,java]
----
...

@Named
@Validated
@Transactional
public class UcManageAccessCodeImpl extends AbstractAccessCodeUc implements UcManageAccessCode {

  private static final int DEFAULT_ESTIMATED_TIME_PER_USER_IN_MILISECONDS = 120000;

  /**
   * Logger instance.
   */
  private static final Logger LOG = LoggerFactory.getLogger(UcManageAccessCodeImpl.class);

  @Override
  public boolean deleteAccessCode(long accessCodeId) {

    AccessCodeEntity accessCode = getAccessCodeRepository().find(accessCodeId);
    getAccessCodeRepository().delete(accessCode);
    LOG.debug("The accessCode with id '{}' has been deleted.", accessCodeId);
    return true;
  }

  @Override
  public AccessCodeEto saveAccessCode(AccessCodeEto accessCode) {

    Objects.requireNonNull(accessCode, "accessCode");

    AccessCodeEntity accessCodeEntity = getBeanMapper().map(accessCode, AccessCodeEntity.class);

    if (accessCodeEntity.getCreatedDate() == null) {
      accessCodeEntity.setCreatedDate(new Timestamp(System.currentTimeMillis()));
    }
    // Initialize, validate accessCodeEntity here if necessary
    AccessCodeEntity resultEntity = getAccessCodeRepository().save(accessCodeEntity);
    LOG.debug("AccessCode with id '{}' has been created.", resultEntity.getId());
    return getBeanMapper().map(resultEntity, AccessCodeEto.class);
  }

  @Inject
  Accesscodemanagement accessCodeManagement;

  @Override
  public void updateCodesOnStartQueue(long queueId) {

    List<AccessCodeEto> accessCodes = this.accessCodeManagement.findByQueue(queueId);
    for (AccessCodeEto eto : accessCodes) {
      AccessCodeEntity entity = getBeanMapper().map(eto, AccessCodeEntity.class);
      entity.setStatus(Status.WAITING);
      getAccessCodeRepository().save(entity);
    }
  }

  @Inject
  Queuemanagement queueManagement;

  @Override
  public NextCodeCto callNextCode() {

    // Get daily queues so we get codes associated with it
    long dailyQueueId = this.queueManagement.findDailyQueue().getId();

    // Check if we have current code being attended
    AccessCodeEto currentCode = this.accessCodeManagement.findCurrentCode();
    if (currentCode.getStatus() == Status.ATTENDING) {
      // Update current code
      currentCode.setStatus(Status.ATTENDED);
      currentCode.setEndTime(new Timestamp(System.currentTimeMillis()));
      getAccessCodeRepository().save(getBeanMapper().map(currentCode, AccessCodeEntity.class));
    }
    // Check if there is a next code else go 2.2
    NextCodeCto nextCodeCto = this.accessCodeManagement.findNextCode(dailyQueueId);
    if (nextCodeCto.getAccessCode() != null && nextCodeCto.getAccessCode().getStatus() == Status.WAITING) {
      // Update this code to attending and startDate and return it
      nextCodeCto.getAccessCode().setStatus(Status.ATTENDING);
      nextCodeCto.getAccessCode().setStartTime(new Timestamp(System.currentTimeMillis()));
      getAccessCodeRepository().save(getBeanMapper().map(nextCodeCto.getAccessCode(), AccessCodeEntity.class));
      // Remove above code from remaining codes
      nextCodeCto.getRemainingCodes().setRemainingCodes(nextCodeCto.getRemainingCodes().getRemainingCodes() - 1);
    }
    // SSE TODO: Refactor this SSE
    List<SseEmitter> sseEmitterListToRemove = new ArrayList<>();
    ServerSse.emitters.forEach((SseEmitter emitter) -> {
      try {
        if (nextCodeCto.getAccessCode() != null) {
          emitter.send(SseEmitter.event().data(nextCodeCto.getAccessCode(), MediaType.APPLICATION_JSON)
              .name("CURRENT_CODE_CHANGED"));
        } else {
          emitter.send(SseEmitter.event().data(new AccessCodeEto(), MediaType.APPLICATION_JSON)
              .name("CURRENT_CODE_CHANGED_NULL"));
        }
      } catch (IOException e) {
        emitter.complete();
        sseEmitterListToRemove.add(emitter);
        LOG.error(e.toString());
      }
    });
    ServerSse.emitters.removeAll(sseEmitterListToRemove);

    return nextCodeCto;
  }

  @Override
  public EstimatedTime calculateEstimatedTime(AccessCodeEto accessCode) {

    EstimatedTime estimated = new EstimatedTime();
    // Get how many codes are ahead of given code
    AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
    criteria.setQueueId(accessCode.getQueueId());
    criteria.setStatus(Status.WAITING);
    criteria.setPageable(PageRequest.of(0, Integer.MAX_VALUE, Sort.by(Sort.Direction.ASC, "createdDate")));
    Page<AccessCodeEntity> result = getAccessCodeRepository().findByCriteria(criteria);

    // TODO: Refactor this
    for (AccessCodeEntity entity : result.getContent()) {
      if (entity.getId().equals(accessCode.getId())) {
        int index = result.getContent().indexOf(entity);
        index = index + 1; // + attending code
        long estimatedInMs = index * DEFAULT_ESTIMATED_TIME_PER_USER_IN_MILISECONDS;
        estimated.setMiliseconds(estimatedInMs);
        estimated.setDefaultTimeByUserInMs(DEFAULT_ESTIMATED_TIME_PER_USER_IN_MILISECONDS);
        return estimated;
      }
    }
    return estimated;
  }
}
----

Now we will deal with the errers in AccesscodemanagementImpl:


We are going to add the needed methods we just defined:

[source, java]
----

	...

	@Inject
	private UcManageAccessCode ucManageAccessCode;
	
	...

	@Override
	public EstimatedTime calculateEstimatedTime(AccessCodeEto code) {
		return this.ucManageAccessCode.calculateEstimatedTime(code);
	}
	
	@Override
	public NextCodeCto callNextCode() {
		return this.ucManageAccessCode.callNextCode();
	}

	@Override
	public void updateCodesOnStartQueue(long queueId) {
		this.ucManageAccessCode.updateCodesOnStartQueue(queueId);
	}

	@Override
	public boolean deleteAccessCode(long id) {

		return this.ucManageAccessCode.deleteAccessCode(id);
	}

	@Override
	public AccessCodeEto saveAccessCode(AccessCodeEto accesscode) {

		return this.ucManageAccessCode.saveAccessCode(accesscode);
	}

----

We now want to be able to find a given accesscode by using its id: We therefore implement another method in `jtqj-api/src/main/java/.../UcFindAccessCode`

[source, java]
----
 
	/**
	 * Returns owners code given by uuid
	 *
	 * @param uuid the uuid 'uuid' of the AccessCode.
	 * @return The {@link AccessCodeEto} with such uuid 'uuid'
	 */
	AccessCodeCto findUuidAccessCode(Uuid uuid);


----

Uuid does not exist yet. Therefore we will add a class `Uuid` in jtqj-api/src/main/java/com/devonfw/application/jtqj/accesscodemanagement/logic/api/to`:

[source,java]
----
package com.devonfw.application.jtqj.accesscodemanagement.logic.api.to;

public class Uuid {

	private String uuid;

	public String getUuid() {
		return uuid;
	}

	public void setUuid(String uuid) {
		this.uuid = uuid;
	}
}
----

We will now import the needed classes in UcFindAccessCode:

[source, java]
----
...
import com.devonfw.application.jtqj.accesscodemanagement.logic.api.to.Uuid;
...
----


Next we will implement the new method in UcFindAccessCodeImpl:

[source, java]
----
@Override
	public AccessCodeCto findUuidAccessCode(Uuid uuid) {
		AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
		AccessCodeCto visitorCode = new AccessCodeCto();
		// Get today's queue
		QueueEto dailyQueue = queueManagement.findDailyQueue();
		visitorCode.setQueue(dailyQueue);
		// Get code associated with uuid and today's queue

		criteria.setQueueId(dailyQueue.getId());
		criteria.setUuid(uuid.getUuid());
		Page<AccessCodeEntity> codes = getAccessCodeRepository().findByCriteria(criteria);
		// create code if user hasn't for today
		if (codes.getContent().isEmpty()) {
			AccessCodeEto newCode = new AccessCodeEto();
			newCode.setUuid(uuid.getUuid());
			newCode.setQueueId(dailyQueue.getId());
			if (dailyQueue.getStarted()) {
				newCode.setStatus(Status.WAITING);
			} else {
				newCode.setStatus(Status.NOTSTARTED);
			}
			AccessCodeEto lastCodeInQueue = getLastCodeInQueue(dailyQueue.getId());
			// is queue empty?
			if (lastCodeInQueue.getCreatedDate() == null) {
				newCode.setCode(QUEUE_LETTER_CODE + FIRST_CODE_IN_QUEUE);
			} else {
				newCode.setCode(nextCodeString(lastCodeInQueue.getCode()));
			}
			AccessCodeEto savedCode = accessCodeManagement.saveAccessCode(newCode);
			visitorCode.setAccessCode(savedCode);

			// SSE that a new code is in the queue
	        List<SseEmitter> sseEmitterListToRemove = new ArrayList<>();
	        ServerSse.emitters.forEach((SseEmitter emitter) -> {
	            try {
	            	emitter.send(SseEmitter.event().data(savedCode, MediaType.APPLICATION_JSON).name("NEW_CODE_ADDED"));
	            } catch (IOException e) {
	                emitter.complete();
	                sseEmitterListToRemove.add(emitter);
	                LOG.error(e.toString());
	            }
	        });
	        ServerSse.emitters.removeAll(sseEmitterListToRemove);
		} else {
			visitorCode.setAccessCode(getBeanMapper().map(codes.getContent().get(0), AccessCodeEto.class));
			visitorCode.setQueue(dailyQueue);
		}
		return visitorCode;
	}

	private String nextCodeString(String codeString) {
		String nextCode = QUEUE_LETTER_CODE + FIRST_CODE_IN_QUEUE;
		if (!codeString.equals(QUEUE_LETTER_CODE + LAST_CODE_IN_QUEUE)) {
			String numbers = codeString.substring(1);
			int number = Integer.parseInt(numbers);
			number = number + 1;
			numbers = String.valueOf(number);
			while (numbers.length() < 3) {
				numbers = "0" + numbers;
			}
			nextCode = QUEUE_LETTER_CODE + numbers;
		}
		return nextCode;
	}

	private AccessCodeEto getLastCodeInQueue(long queueId) {
		AccessCodeEto lastCode = new AccessCodeEto();
		AccessCodeSearchCriteriaTo criteria = new AccessCodeSearchCriteriaTo();
		criteria.setQueueId(queueId);
		criteria.setPageable(PageRequest.of(0, 1, Sort.by(Sort.Direction.DESC, "createdDate")));
		Page<AccessCodeEntity> accessCodes = getAccessCodeRepository().findByCriteria(criteria);
		if (accessCodes.getContent().size() == 1) {
			lastCode = getBeanMapper().map(accessCodes.getContent().get(0), AccessCodeEto.class);
		}
		return lastCode;
	}

----

We will need to import `MediaType` via  `import org.springframework.http.MediaType;`

Add `findUuidAccessCode` to `AccesscodemanagementImpl`:


[source,java]
----
	@Override
	public AccessCodeCto findUuidAccessCode(Uuid uuid) {
		return ucFindAccessCode.findUuidAccessCode(uuid);
	}
----


import List in `jtqj-core` -> `Accesscodemanagement`


=== Adding to the Service
To add the new service, we need to add its definition to the `jtqj-api` in `accesscodemanagement/service/api/rest/AccesscodemanagementRestService.java`. We are going to create a new `/accessCode` REST resource bound to three methods, one called _findAccessCodeEtos_, another one called _saveAccessCode_ and yet another one called _deleteAccessCode_.

[source,java]
----
...

@Path("/accesscodemanagement/v1")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public interface AccesscodemanagementRestService {

	/**
	 * Delegates to {@link Accesscodemanagement#findAccessCode}.
	 *
	 * @param id the ID of the {@link AccessCodeEto}
	 * @return the {@link AccessCodeEto}
	 */
	@GET
	@Path("/accesscode/{id}/")
	public AccessCodeEto getAccessCode(@PathParam("id") long id);

	/**
	 * Delegates to {@link Accesscodemanagement#saveAccessCode}.
	 *
	 * @param accesscode the {@link AccessCodeEto} to be saved
	 * @return the recently created {@link AccessCodeEto}
	 */
	@POST
	@Path("/accesscode/")
	public AccessCodeEto saveAccessCode(AccessCodeEto accesscode);

	/**
	 * Delegates to {@link Accesscodemanagement#deleteAccessCode}.
	 *
	 * @param id ID of the {@link AccessCodeEto} to be deleted
	 */
	@DELETE
	@Path("/accesscode/{id}/")
	public void deleteAccessCode(@PathParam("id") long id);

	/**
	 * Delegates to {@link Accesscodemanagement#findAccessCodeEtos}.
	 *
	 * @param searchCriteriaTo the pagination and search criteria to be used for
	 *                         finding accesscodes.
	 * @return the {@link Page list} of matching {@link AccessCodeEto}s.
	 */
	@Path("/accesscode/search")
	@POST
	public Page<AccessCodeEto> findAccessCodes(AccessCodeSearchCriteriaTo searchCriteriaTo);

	/**
	 * Delegates to {@link Accesscodemanagement#findUuidAccessCode}.
	 *
	 * @param uuid the uuid related to the accessCode in DB, if not found will create it
	 * @return the {@link AccessCodeCto}.
	 */
	@Path("/accesscode/uuid")
	@POST
	public AccessCodeCto findUuidAccessCode(Uuid uuid);

	/**
	 * Delegates to {@link Accesscodemanagement#callNextCode}.
	 *
	 * @return the next accessCode if available{@link AccessCodeCto}.
	 */
	@Path("/accesscode/next")
	@POST
	public NextCodeCto callNextCode();

	/**
	 * Delegates to {@link Accesscodemanagement#findCurrentCode}.
	 *
	 * @return the current accessCode if available{@link AccessCodeEto}.
	 */
	@Path("/accesscode/current")
	@POST
	public AccessCodeEto findCurrentCode();

	/**
	 * Delegates to {@link Accesscodemanagement#calculateEstimatedTime}.
	 *
	 * @param code
	 * @return the the estimated time {@link EstimatedTime}.
	 */
	@Path("/accesscode/estimated")
	@POST
	public EstimatedTime getEstimatedTime(AccessCodeEto code);

	/**
	 * Delegates to {@link Accesscodemanagement#remainingCodes}.
	 *
	 * @return how many codes with status == waiting {@link RemainingCode}.
	 */
	@Path("/accesscode/remaining")
	@POST
	public RemainingCodes getRemaningCodes();


}
----


Then we need to implement the new methods in the `accesscodemanagement/service/impl/rest/AccesscodemanagementRestServiceImpl.java` class:

[source,java]
----
...

@Named("AccesscodemanagementRestService")
public class AccesscodemanagementRestServiceImpl implements AccesscodemanagementRestService {

	...

	@Override
	public AccessCodeEto getAccessCode(long id) {
		return this.accesscodemanagement.findAccessCode(id);
	}

	@Override
	public AccessCodeEto saveAccessCode(AccessCodeEto accesscode) {
		return this.accesscodemanagement.saveAccessCode(accesscode);
	}

	@Override
	public void deleteAccessCode(long id) {
		this.accesscodemanagement.deleteAccessCode(id);
	}

	@Override
	public Page<AccessCodeEto> findAccessCodes(AccessCodeSearchCriteriaTo searchCriteriaTo) {
		return this.accesscodemanagement.findAccessCodes(searchCriteriaTo);
	}

	@Override
	public AccessCodeCto findUuidAccessCode(Uuid uuid) {
		return this.accesscodemanagement.findUuidAccessCode(uuid);
	}

	@Override
	public NextCodeCto callNextCode() {
		return this.accesscodemanagement.callNextCode();
	}

	@Override
	public AccessCodeEto findCurrentCode() {
		return this.accesscodemanagement.findCurrentCode();
	}

	@Override
	public EstimatedTime getEstimatedTime(AccessCodeEto code) {
		return this.accesscodemanagement.calculateEstimatedTime(code);
	}

	@Override
	public RemainingCodes getRemaningCodes() {
		return this.accesscodemanagement.findRemainingCodes();
	}

}
----
To resolve th errors, import the needed Packages.
=== Testing the Changes
Now run the app again via Eclipse and use Postman to call the new save service via *POST*: +
`http://localhost:8081/jumpthequeue/services/rest/accesscodemanagement/v1/accesscode/`

In the body, provide an AccessCode object with the following required parameters:

//TODO: This fails due to an SQL Error: 23506

[source,json]
----
{
  "queueId" : "1",
  "visitorId" : "1000000"
}
----

The result should be something similar to this:

image::images/devon4j/6.Customizations/jumpthequeue_accesscode.png[JumpTheQueue AccessCode]

In order to know, if the new codeaccess has been succesfully created, we can search all the CTOs, like we did in the previous steps. The new accesscode should be on the bottom:

image::images/devon4j/6.Customizations/jumpthequeue_listwithcode.png[JumpTheQueue List with Code]

To test the delete, you can send a *DELETE* to this URL:
`http://localhost:8081/jumpthequeue/services/rest/accesscodemanagement/v1/accesscode/{id}`
Pass the _AccessCode_ ID of the new entry, which can be found in the returned result of the save or the search operation.

In this chapter we learned, how easy it is to extend a _devon4j_ application. With only a few steps you can add new services to your backend, to fit the functional requirements of your project, or edit services to adapt the default implementation to your needs.

In the next chapter we will show how to add validations for the data, that we receive from the client.

'''
*Next Chapter*: link:devon4j-validations.asciidoc[Validations in devon4j]
